// node_modules/@pionjs/pion/lib/interface.js
var current;
var currentId = 0;
function setCurrent(state) {
  current = state;
}
function clear() {
  current = null;
  currentId = 0;
}
function notify() {
  return currentId++;
}

// node_modules/@pionjs/pion/lib/symbols.js
var phaseSymbol = Symbol("haunted.phase");
var hookSymbol = Symbol("haunted.hook");
var updateSymbol = Symbol("haunted.update");
var commitSymbol = Symbol("haunted.commit");
var effectsSymbol = Symbol("haunted.effects");
var layoutEffectsSymbol = Symbol("haunted.layoutEffects");
var contextEvent = "haunted.context";

// node_modules/@pionjs/pion/lib/state.js
var State = class {
  update;
  host;
  virtual;
  [hookSymbol];
  [effectsSymbol];
  [layoutEffectsSymbol];
  constructor(update, host) {
    this.update = update;
    this.host = host;
    this[hookSymbol] = /* @__PURE__ */ new Map();
    this[effectsSymbol] = [];
    this[layoutEffectsSymbol] = [];
  }
  run(cb) {
    setCurrent(this);
    let res = cb();
    clear();
    return res;
  }
  _runEffects(phase) {
    let effects = this[phase];
    setCurrent(this);
    for (let effect of effects) {
      effect.call(this);
    }
    clear();
  }
  runEffects() {
    this._runEffects(effectsSymbol);
  }
  runLayoutEffects() {
    this._runEffects(layoutEffectsSymbol);
  }
  teardown() {
    let hooks = this[hookSymbol];
    hooks.forEach((hook2) => {
      if (typeof hook2.teardown === "function") {
        hook2.teardown(true);
      }
    });
  }
};

// node_modules/@pionjs/pion/lib/scheduler.js
var defer = Promise.resolve().then.bind(Promise.resolve());
function runner() {
  let tasks = [];
  let id;
  function runTasks() {
    id = null;
    let t = tasks;
    tasks = [];
    for (var i = 0, len = t.length; i < len; i++) {
      t[i]();
    }
  }
  return function(task) {
    tasks.push(task);
    if (id == null) {
      id = defer(runTasks);
    }
  };
}
var read = runner();
var write = runner();
var BaseScheduler = class {
  renderer;
  host;
  state;
  [phaseSymbol];
  _updateQueued;
  _active;
  constructor(renderer, host) {
    this.renderer = renderer;
    this.host = host;
    this.state = new State(this.update.bind(this), host);
    this[phaseSymbol] = null;
    this._updateQueued = false;
    this._active = true;
  }
  update() {
    if (!this._active)
      return;
    if (this._updateQueued)
      return;
    read(() => {
      let result = this.handlePhase(updateSymbol);
      write(() => {
        this.handlePhase(commitSymbol, result);
        write(() => {
          this.handlePhase(effectsSymbol);
        });
      });
      this._updateQueued = false;
    });
    this._updateQueued = true;
  }
  handlePhase(phase, arg) {
    this[phaseSymbol] = phase;
    switch (phase) {
      case commitSymbol:
        this.commit(arg);
        this.runEffects(layoutEffectsSymbol);
        return;
      case updateSymbol:
        return this.render();
      case effectsSymbol:
        return this.runEffects(effectsSymbol);
    }
  }
  render() {
    return this.state.run(() => this.renderer.call(this.host, this.host));
  }
  runEffects(phase) {
    this.state._runEffects(phase);
  }
  teardown() {
    this.state.teardown();
  }
  pause() {
    this._active = false;
  }
  resume() {
    this._active = true;
  }
};

// node_modules/@pionjs/pion/lib/util.js
var sheet = (...styles) => {
  const cs = new CSSStyleSheet();
  cs.replaceSync(styles.join(""));
  return cs;
};
var sheets = (styleSheets) => styleSheets?.map((style) => {
  if (typeof style === "string")
    return sheet(style);
  return style;
});
var tagged = (strings, ...values) => strings.flatMap((s, i) => [s, values[i] || ""]).join("");
var css = tagged;

// node_modules/@pionjs/pion/lib/component.js
var toCamelCase = (val = "") => val.replace(/-+([a-z])?/g, (_, char) => char ? char.toUpperCase() : "");
function makeComponent(render) {
  class Scheduler extends BaseScheduler {
    frag;
    renderResult;
    constructor(renderer, frag, host) {
      super(renderer, host || frag);
      this.frag = frag;
    }
    commit(result) {
      this.renderResult = render(result, this.frag);
    }
  }
  function component(renderer, baseElementOrOptions, options) {
    const BaseElement = (options || baseElementOrOptions || {}).baseElement || HTMLElement;
    const { observedAttributes = [], useShadowDOM = true, shadowRootInit = {}, styleSheets: _styleSheets } = options || baseElementOrOptions || {};
    const styleSheets = sheets(renderer.styleSheets || _styleSheets);
    class Element2 extends BaseElement {
      _scheduler;
      static get observedAttributes() {
        return renderer.observedAttributes || observedAttributes || [];
      }
      constructor() {
        super();
        if (useShadowDOM === false) {
          this._scheduler = new Scheduler(renderer, this);
        } else {
          const shadowRoot = this.attachShadow({
            mode: "open",
            ...shadowRootInit
          });
          if (styleSheets)
            shadowRoot.adoptedStyleSheets = styleSheets;
          this._scheduler = new Scheduler(renderer, shadowRoot, this);
        }
      }
      connectedCallback() {
        this._scheduler.resume();
        this._scheduler.update();
        this._scheduler.renderResult?.setConnected(true);
      }
      disconnectedCallback() {
        this._scheduler.pause();
        this._scheduler.teardown();
        this._scheduler.renderResult?.setConnected(false);
      }
      attributeChangedCallback(name, oldValue, newValue) {
        if (oldValue === newValue) {
          return;
        }
        let val = newValue === "" ? true : newValue;
        Reflect.set(this, toCamelCase(name), val);
      }
    }
    function reflectiveProp(initialValue) {
      let value = initialValue;
      let isSetup = false;
      return Object.freeze({
        enumerable: true,
        configurable: true,
        get() {
          return value;
        },
        set(newValue) {
          if (isSetup && value === newValue)
            return;
          isSetup = true;
          value = newValue;
          if (this._scheduler) {
            this._scheduler.update();
          }
        }
      });
    }
    const proto = new Proxy(BaseElement.prototype, {
      getPrototypeOf(target) {
        return target;
      },
      set(target, key, value, receiver) {
        let desc;
        if (key in target) {
          desc = Object.getOwnPropertyDescriptor(target, key);
          if (desc && desc.set) {
            desc.set.call(receiver, value);
            return true;
          }
          Reflect.set(target, key, value, receiver);
          return true;
        }
        if (typeof key === "symbol" || key[0] === "_") {
          desc = {
            enumerable: true,
            configurable: true,
            writable: true,
            value
          };
        } else {
          desc = reflectiveProp(value);
        }
        Object.defineProperty(receiver, key, desc);
        if (desc.set) {
          desc.set.call(receiver, value);
        }
        return true;
      }
    });
    Object.setPrototypeOf(Element2.prototype, proto);
    return Element2;
  }
  return component;
}

// node_modules/@pionjs/pion/lib/hook.js
var Hook = class {
  id;
  state;
  constructor(id, state) {
    this.id = id;
    this.state = state;
  }
};
function use(Hook2, ...args) {
  let id = notify();
  let hooks = current[hookSymbol];
  let hook2 = hooks.get(id);
  if (!hook2) {
    hook2 = new Hook2(id, current, ...args);
    hooks.set(id, hook2);
  }
  return hook2.update(...args);
}
function hook(Hook2) {
  return use.bind(null, Hook2);
}

// node_modules/@pionjs/pion/lib/create-effect.js
function createEffect(setEffects2) {
  return hook(class extends Hook {
    callback;
    lastValues;
    values;
    _teardown;
    constructor(id, state, ignored1, ignored2) {
      super(id, state);
      setEffects2(state, this);
    }
    update(callback, values) {
      this.callback = callback;
      this.values = values;
    }
    call() {
      const hasChanged = !this.values || this.hasChanged();
      this.lastValues = this.values;
      if (hasChanged) {
        this.run();
      }
    }
    run() {
      this.teardown();
      this._teardown = this.callback.call(this.state);
    }
    teardown(disconnected) {
      if (typeof this._teardown === "function") {
        this._teardown();
        this._teardown = void 0;
      }
      if (disconnected) {
        this.lastValues = this.values = void 0;
      }
    }
    hasChanged() {
      return !this.lastValues || this.values.some((value, i) => this.lastValues[i] !== value);
    }
  });
}

// node_modules/@pionjs/pion/lib/use-effect.js
function setEffects(state, cb) {
  state[effectsSymbol].push(cb);
}
var useEffect = createEffect(setEffects);

// node_modules/@pionjs/pion/lib/use-context.js
var getEmitter = (host) => {
  if (host instanceof Element)
    return host;
  return host.startNode || host.endNode || host.parentNode;
};
var useContext = hook(class extends Hook {
  Context;
  value;
  _ranEffect;
  _unsubscribe;
  constructor(id, state, _) {
    super(id, state);
    this._updater = this._updater.bind(this);
    this._ranEffect = false;
    this._unsubscribe = null;
    setEffects(state, this);
  }
  update(Context) {
    if (this.Context !== Context) {
      this._subscribe(Context);
      this.Context = Context;
    }
    return this.value;
  }
  call() {
    if (!this._ranEffect) {
      this._ranEffect = true;
      if (this._unsubscribe)
        this._unsubscribe();
      this._subscribe(this.Context);
      this.state.update();
    }
  }
  _updater(value) {
    this.value = value;
    this.state.update();
  }
  _subscribe(Context) {
    const detail = { Context, callback: this._updater };
    const emitter = getEmitter(this.state.host);
    emitter.dispatchEvent(new CustomEvent(contextEvent, {
      detail,
      // carrier
      bubbles: true,
      // to bubble up in tree
      cancelable: true,
      // to be able to cancel
      composed: true
      // to pass ShadowDOM boundaries
    }));
    const { unsubscribe = null, value } = detail;
    this.value = unsubscribe ? value : Context.defaultValue;
    this._unsubscribe = unsubscribe;
  }
  teardown() {
    if (this._unsubscribe) {
      this._unsubscribe();
    }
  }
});

// node_modules/@pionjs/pion/lib/create-context.js
function makeContext(component) {
  return (defaultValue) => {
    const Context = {
      Provider: class extends HTMLElement {
        listeners;
        _value;
        constructor() {
          super();
          this.style.display = "contents";
          this.listeners = /* @__PURE__ */ new Set();
          this.addEventListener(contextEvent, this);
        }
        disconnectedCallback() {
          this.removeEventListener(contextEvent, this);
        }
        handleEvent(event) {
          const { detail } = event;
          if (detail.Context === Context) {
            detail.value = this.value;
            detail.unsubscribe = this.unsubscribe.bind(this, detail.callback);
            this.listeners.add(detail.callback);
            event.stopPropagation();
          }
        }
        unsubscribe(callback) {
          this.listeners.delete(callback);
        }
        set value(value) {
          this._value = value;
          for (let callback of this.listeners) {
            callback(value);
          }
        }
        get value() {
          return this._value;
        }
      },
      Consumer: component(function({ render }) {
        const context = useContext(Context);
        return render(context);
      }, { useShadowDOM: false }),
      defaultValue
    };
    return Context;
  };
}

// node_modules/@pionjs/pion/lib/use-memo.js
var useMemo = hook(class extends Hook {
  value;
  values;
  constructor(id, state, fn, values) {
    super(id, state);
    this.value = fn();
    this.values = values;
  }
  update(fn, values) {
    if (this.hasChanged(values)) {
      this.values = values;
      this.value = fn();
    }
    return this.value;
  }
  hasChanged(values = []) {
    return values.some((value, i) => this.values[i] !== value);
  }
});

// node_modules/@pionjs/pion/lib/use-callback.js
var useCallback = (fn, inputs) => useMemo(() => fn, inputs);

// node_modules/@pionjs/pion/lib/use-layout-effect.js
function setLayoutEffects(state, cb) {
  state[layoutEffectsSymbol].push(cb);
}
var useLayoutEffect = createEffect(setLayoutEffects);

// node_modules/@pionjs/pion/lib/use-state.js
var useState = hook(class extends Hook {
  args;
  constructor(id, state, initialValue) {
    super(id, state);
    this.updater = this.updater.bind(this);
    if (typeof initialValue === "function") {
      const initFn = initialValue;
      initialValue = initFn();
    }
    this.makeArgs(initialValue);
  }
  update() {
    return this.args;
  }
  updater(value) {
    const [previousValue] = this.args;
    if (typeof value === "function") {
      const updaterFn = value;
      value = updaterFn(previousValue);
    }
    if (Object.is(previousValue, value)) {
      return;
    }
    this.makeArgs(value);
    this.state.update();
  }
  makeArgs(value) {
    this.args = Object.freeze([value, this.updater]);
  }
});

// node_modules/@pionjs/pion/lib/use-reducer.js
var useReducer = hook(class extends Hook {
  reducer;
  currentState;
  constructor(id, state, _, initialState, init) {
    super(id, state);
    this.dispatch = this.dispatch.bind(this);
    this.currentState = init !== void 0 ? init(initialState) : initialState;
  }
  update(reducer) {
    this.reducer = reducer;
    return [this.currentState, this.dispatch];
  }
  dispatch(action) {
    this.currentState = this.reducer(this.currentState, action);
    this.state.update();
  }
});

// node_modules/@pionjs/pion/lib/use-property.js
var UPPER = /([A-Z])/gu;
var useProperty = hook(class extends Hook {
  property;
  eventName;
  constructor(id, state, property, initialValue) {
    super(id, state);
    if (this.state.virtual) {
      throw new Error("Can't be used with virtual components.");
    }
    this.updater = this.updater.bind(this);
    this.property = property;
    this.eventName = property.replace(UPPER, "-$1").toLowerCase() + "-changed";
    if (this.state.host[this.property] != null)
      return;
    if (typeof initialValue === "function") {
      const initFn = initialValue;
      initialValue = initFn();
    }
    if (initialValue == null)
      return;
    this.updateProp(initialValue);
  }
  update(ignored, ignored2) {
    return [this.state.host[this.property], this.updater];
  }
  updater(value) {
    const previousValue = this.state.host[this.property];
    if (typeof value === "function") {
      const updaterFn = value;
      value = updaterFn(previousValue);
    }
    if (Object.is(previousValue, value)) {
      return;
    }
    this.updateProp(value);
  }
  updateProp(value) {
    const ev = this.notify(value);
    if (ev.defaultPrevented)
      return;
    this.state.host[this.property] = value;
  }
  notify(value) {
    const ev = new CustomEvent(this.eventName, {
      detail: { value, path: this.property },
      cancelable: true
    });
    this.state.host.dispatchEvent(ev);
    return ev;
  }
});
var lift = (setter) => (ev) => {
  ev.preventDefault();
  setter(ev.detail.value);
};

// node_modules/@pionjs/pion/lib/use-ref.js
function useRef(initialValue) {
  return useMemo(() => ({
    current: initialValue
  }), []);
}

// node_modules/@pionjs/pion/lib/core.js
function pion({ render }) {
  const component = makeComponent(render);
  const createContext = makeContext(component);
  return { component, createContext };
}

export {
  State,
  BaseScheduler,
  sheet,
  sheets,
  tagged,
  css,
  Hook,
  hook,
  useEffect,
  useContext,
  useMemo,
  useCallback,
  useLayoutEffect,
  useState,
  useReducer,
  useProperty,
  lift,
  useRef,
  pion
};
//# sourceMappingURL=chunk-MSQIAPQN.js.map
